<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }

        canvas {
            border: 1px solid #000;
        }

        .button-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        button {
            margin: 5px;
        }
    </style>
    <title>Simple Drawing App</title>
</head>
<body>
    <canvas id="drawingCanvas" width="400" height="400"></canvas>
    
    <div class="button-container">
        <button onclick="rotateImage(90)">
            <img src="https://i.imgur.com/2eoKtwv.png" alt="Rotate 90">
            Rotate 90ยบ
        </button>

        <button onclick="rotateImage(180)">
            <img src="https://i.imgur.com/R0cbqyf.png" alt="Rotate 180">
            Rotate 180ยบ
        </button>

        <button onclick="rotateImage(270)">
            <img src="https://i.imgur.com/ZbHwcTh.png" alt="Rotate 270">
            Rotate 270ยบ
        </button>
        
        <button onclick="resetCanvas()">
            <img src="reset.png" alt="Reset">
            Reset
        </button>        
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const context = canvas.getContext('2d');
        let isDrawing = false;
        let startPoint = { x: 0, y: 0 };
        let lines = [];

const imageUrl = 'https://i.imgur.com/shPjgYD.png';

// Load image
const backgroundImage = new Image();
backgroundImage.src = imageUrl;

// Draw the background image
backgroundImage.onload = function () {
    context.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);
};



        // Draw a non-deletable circle in the middle
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const circleRadius = 50;

        function drawCircle() {
            context.beginPath();
            context.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
            context.fillStyle = 'blue';
            context.fill();
            context.lineWidth = 2;
            context.strokeStyle = 'black';
            context.stroke();
        }

        function drawLines() {
    context.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);

    lines.forEach(line => {
        context.beginPath();
        context.moveTo(line.start.x, line.start.y);
        context.lineTo(line.end.x, line.end.y);
        context.lineCap = 'round';
        context.lineWidth = 10;
        context.stroke();
    });
}


        function startDrawing(e) {
            isDrawing = true;
            startPoint = { x: e.clientX - canvas.offsetLeft, y: e.clientY - canvas.offsetTop };
        }

        function drawLine(e) {
    if (!isDrawing) return;

    // Calculate the angle of the line
    const angle = Math.atan2(e.clientY - canvas.offsetTop - startPoint.y, e.clientX - canvas.offsetLeft - startPoint.x);
    const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);

    // Calculate the intersection point with the canvas boundaries
    const intersectionPoint = getIntersectionPoint(startPoint.x, startPoint.y, snappedAngle, canvas.width, canvas.height);

    drawLines();
    context.beginPath();
    context.moveTo(startPoint.x, startPoint.y);
    context.lineTo(intersectionPoint.x, intersectionPoint.y);
    context.lineCap = 'round';
    context.lineWidth = 10;
    context.stroke();
}

// Function to calculate the intersection point with canvas boundaries
function getIntersectionPoint(x, y, angle, canvasWidth, canvasHeight) {
    // Calculate the intersection with each canvas boundary
    const intersectionTop = { x: x + (canvasHeight - y) / Math.tan(angle), y: canvasHeight };
    const intersectionBottom = { x: x - y / Math.tan(angle), y: 0 };
    const intersectionLeft = { x: 0, y: y - x * Math.tan(angle) };
    const intersectionRight = { x: canvasWidth, y: y + (canvasWidth - x) * Math.tan(angle) };

    // Find the closest intersection point
    const intersections = [intersectionTop, intersectionBottom, intersectionLeft, intersectionRight];
    const closestIntersection = intersections.reduce((closest, point) => {
        const distance = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
        return distance < closest.distance ? { point, distance } : closest;
    }, { point: null, distance: Infinity });

    return closestIntersection.point;
}



function stopDrawing(e) {
    if (!isDrawing) return;
    isDrawing = false;

    // Calculate the angle of the line
    const angle = Math.atan2(e.clientY - canvas.offsetTop - startPoint.y, e.clientX - canvas.offsetLeft - startPoint.x);
    const snappedAngle = Math.round(angle / (Math.PI / 4)) * (Math.PI / 4);

    // Calculate the intersection point with the canvas boundaries
    const intersectionPoint = getIntersectionPoint(startPoint.x, startPoint.y, snappedAngle, canvas.width, canvas.height);

    lines.push({ start: { ...startPoint }, end: { ...intersectionPoint } });
    drawLines();
}


        function rotateImage(degrees) {
            // Create a new canvas for drawing operations
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempContext = tempCanvas.getContext('2d');

            // Draw the non-deletable circle on the temporary canvas
            drawCircle(tempContext);

            // Draw the existing drawing on the temporary canvas
            tempContext.drawImage(canvas, 0, 0);

            // Clear the main canvas
            context.clearRect(0, 0, canvas.width, canvas.height);

            // Apply rotation on the main canvas
            context.save();
            context.translate(canvas.width / 2, canvas.height / 2);
            context.rotate((degrees * Math.PI) / 180);
            context.translate(-canvas.width / 2, -canvas.height / 2);

            // Draw the non-deletable circle on the main canvas
            drawCircle();

            // Draw the rotated drawing from the temporary canvas on the main canvas
            context.drawImage(tempCanvas, 0, 0);

            context.restore();
        }

        function resetCanvas() {
            lines = [];
            context.clearRect(0, 0, canvas.width, canvas.height);
            // Redraw the non-deletable circle
            drawCircle();
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', drawLine);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Initial draw of the non-deletable circle
        drawCircle();
    </script>
</body>
</html>
